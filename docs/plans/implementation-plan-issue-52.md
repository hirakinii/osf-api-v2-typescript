## MCP サーバー実装計画 (issue-52)

### 1. 目的

`osf-api-v2-typescript` プロジェクト内の TypeScript コードベースから、クラス、インターフェース、関数、型などのコードシンボル情報を抽出し、Serena のツールを通じて参照可能な MCP サーバーを実装する。これにより、開発者はコードベース内のエンティティ定義を効率的に検索し、理解できるようになる。

### 2. 要求事項

- プロジェクト内の `src` ディレクトリ以下の TypeScript ファイルを対象とする。
- クラス、インターフェース、関数、型エイリアス、enum などの定義を識別する。
- 各シンボルの名前、種類、定義場所（ファイルパス、行番号）、および必要に応じて簡易なシグネチャまたは定義の一部を提供できること。
- Serena の既存のシンボル検索ツール (`find_symbol`, `get_symbols_overview`) と連携し、それらの機能を拡張する形で情報を提供すること。

### 3. アーキテクチャ

Serena の MCP (Managed Codebase Provider) として動作させるため、既存の Serena のツールを活用することを前提とする。MCP サーバー自体は、プロジェクトのビルドプロセスに統合され、コードベースの変更時にシンボル情報を更新するメカニズムを持つことが理想的。

- **コンポーネント**:
  - **シンボルエクストラクタ**: TypeScript ソースコードを解析し、シンボル情報を抽出する。
  - **データストア**: 抽出されたシンボル情報を格納する。ファイルベース、またはインメモリでシンプルに構成する。
  - **Serena ツールラッパー**: Serena の `find_symbol` などと連携し、リクエストに応じてシンボル情報を提供するインターフェース。

### 4. 実装詳細

#### 4.1. シンボルエクストラクタ

- TypeScript Compiler API または `ts-morph` のようなライブラリを使用して、AST (Abstract Syntax Tree) を解析し、シンボル情報を抽出する。
- 抽出する情報:
  - `name`: シンボル名
  - `kind`: シンボルの種類 (e.g., Class, Interface, Function, TypeAlias)
  - `filePath`: 定義されているファイルのパス
  - `startLine`, `endLine`: 定義の開始行と終了行
  - `signature` または `bodyExcerpt`: 関数のシグネチャ、インターフェースのプロパティリストなど、簡易な定義内容。

#### 4.2. データストア

- 抽出したシンボル情報を JSON 形式でファイルに保存することを検討する。これにより、サーバーの起動時にメモリにロードし、検索を高速化できる。
- 例: `symbol_data.json`

#### 4.3. Serena ツールとの連携

- Serena のツールは、エージェントがコードベースを理解するための基本的なシンボル情報を提供する。MCP サーバーは、これらのツールが提供する情報に加えて、より具体的な TypeScript の型情報などを提供することを目指す。
- 既存の `find_symbol` や `get_symbols_overview` の結果を補完する形で、詳細な型情報を追加する、あるいは独自の検索ツールとして提供する。

### 5. テスト計画

**必ず Test-Driven Development (TDD) スタイルでコードの実装に取り組むこと。**

- **単体テスト**:
  - シンボルエクストラクタが正しくシンボル情報を抽出できることを検証する。
  - 異なる種類の TypeScript シンボル（クラス、インターフェース、関数、型エイリアス、enum、変数など）をカバーするテストケースを作成する。
- **統合テスト**:
  - Serena のツールと連携した際に、期待されるシンボル情報が取得できることを検証する。
  - 特定のクエリに対して、正確なシンボル定義が返されることを確認する。

### 6. 今後の課題・拡張性

- シンボル間の関係性（継承、実装、使用箇所など）の追跡。
- ドキュメンテーションコメント（JSDoc）の抽出と提供。
- MCP サーバーのデプロイメントとライフサイクル管理。
